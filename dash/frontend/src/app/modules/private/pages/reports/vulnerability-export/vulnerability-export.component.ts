import {Component, OnInit} from '@angular/core';
import {ReportsService} from '../../../../../core/services/reports.service';
import {ActivatedRoute} from '@angular/router';
import {IVulnerabilityExportItem} from '../../../../../core/entities/IVulnerabilityExportItem';
import {take} from 'rxjs/operators';
import {MatTableDataSource} from '@angular/material/table';
import {VulnerabilitySeverity} from '../../../../../core/enum/VulnerabilitySeverity';
import {FormBuilder, FormGroup, Validators} from '@angular/forms';
import {NamespaceService} from '../../../../../core/services/namespace.service';
import {NgxUiLoaderService} from 'ngx-ui-loader';
import {CsvService} from '../../../../../core/services/csv.service';
import {format} from 'date-fns';
import {CustomValidatorService} from '../../../../../core/services/custom-validator.service';
import {EnumService} from '../../../../../core/services/enum.service';
import {MatSnackBar} from '@angular/material/snack-bar';


@Component({
  selector: 'app-vulnerability-export',
  templateUrl: './vulnerability-export.component.html',
  styleUrls: ['./vulnerability-export.component.scss']
})
export class VulnerabilityExportComponent implements OnInit {
  clusterId: number;
  vulnerabilityCount: number;
  limit: number;
  vulnerabilities: Array<IVulnerabilityExportItem>;
  dataSource: MatTableDataSource<IVulnerabilityExportItem>;
  displayedColumns: string[] = ['image', 'imageId', 'namespaces', 'scannerName', 'type', 'package', 'isFixable', 'runningInCluster', 'severity'];
  filterForm: FormGroup;
  vulnerabilitySeverities: Array<VulnerabilitySeverity>;
  clusterNamespaces: Array<string>;
  previousRequest: {namespaces, severityLevels, fixAvailable, date};

  constructor(
    private reportsService: ReportsService,
    private route: ActivatedRoute,
    private formBuilder: FormBuilder,
    private namespaceService: NamespaceService,
    private loaderService: NgxUiLoaderService,
    private csvService: CsvService,
    private customValidatorService: CustomValidatorService,
    private enumService: EnumService,
    private snackBar: MatSnackBar,
  ) {
  }

  ngOnInit() {
    this.limit = 20;
    this.route.parent.parent.params
      .pipe(take(1))
      .subscribe(param => this.clusterId = param.id);
    this.buildReport(this.limit, this.clusterId);

    this.vulnerabilitySeverities = this.enumService.getEnumValues(VulnerabilitySeverity);

    this.namespaceService.getAllK8sNamespaces(this.clusterId)
      .pipe(take(1))
      .subscribe((response) => {
        this.clusterNamespaces = new Array<string>();
        for (const namespace of response.data) {
          this.clusterNamespaces.push(namespace.name);
        }
        this.clusterNamespaces.sort();
      });

    this.filterForm = this.formBuilder.group({
      limit: [this.limit, [Validators.required, Validators.min(1), Validators.max(100)]],
      namespaces: [[]],
      severityLevels: [[]],
      fixAvailable: [],
      date: ['', this.customValidatorService.dateInPastOrToday],
    });
  }

  buildReport(limit: number, clusterId: number, namespaces?: string[], severityLevels?: Array<VulnerabilitySeverity>,
              fixAvailable?: boolean, date?: string) {
    this.reportsService.getVulnerabilityExport(limit, clusterId, namespaces, severityLevels, fixAvailable, date)
      .pipe(take(1))
      .subscribe((response) => {
        this.vulnerabilityCount = response.data.count;
        this.vulnerabilities = response.data.results;
        this.dataSource = new MatTableDataSource(response.data.results);
        if (this.vulnerabilityCount < this.limit) {
          this.limit = this.vulnerabilityCount;
        }
      }, (err) => {
        this.snackBar.open(err.error.message, 'Close');
      });
  }

  rebuildWithFilters() {
    if (!this.filtersValid) {
      this.snackBar.open('Invalid filter settings; please recheck filter values', 'Close');
    }
    else {
      let targetDate: string;
      if (this.filterForm.get('date').value) {
        targetDate = format(this.filterForm.get('date').value, 'yyyy-MM-dd');
      }
      this.limit = this.filterForm.get('limit').value;
      this.previousRequest = {
        namespaces: this.filterForm.get('namespaces').value,
        severityLevels: this.filterForm.get('severityLevels').value,
        fixAvailable: this.filterForm.get('fixAvailable').value,
        date: targetDate
      };
      this.buildReport(
        this.limit,
        this.clusterId,
        this.filterForm.get('namespaces').value,
        this.filterForm.get('severityLevels').value,
        this.filterForm.get('fixAvailable').value,
        targetDate,
      );
    }
  }

  get filtersValid(): boolean {
    return this.filterForm.valid;
  }

  downloadReport() {
    this.loaderService.start('csv-download');
    this.reportsService.downloadVulnerabilityExport(this.clusterId, this.previousRequest?.namespaces,
                      this.previousRequest?.severityLevels, this.previousRequest?.fixAvailable, this.previousRequest?.date)
      .pipe(take(1))
      .subscribe((response) => {
        this.csvService.downloadCsvFile(response.data.csv, response.data.filename);
      }, (error) => {
        this.loaderService.stop('csv-download');
        this.snackBar.open(`Error downloading report: ${error.error.message}`, 'Close');
      }, () => {
        this.loaderService.stop('csv-download');
      });
  }
}

